\documentclass[a4paper,11pt,titlepage]{article}
\usepackage[utf8]{inputenc} %support de l'utf8
\usepackage[T1]{fontenc} %support des accents
\usepackage[francais]{babel} %support de la langue
\usepackage{geometry}
\usepackage{listings}
\usepackage{color}
\usepackage{float} 
\usepackage{url}
\geometry{hscale=0.70,vscale=0.70,centering}
\usepackage{graphicx}
\usepackage{pstricks}
\usepackage{pst-tree}

\setcounter{secnumdepth}{4} % Augmente profondeur 
\setcounter{tocdepth}{4} % Augmente profondeur table des matieres
\makeatletter
\renewcommand{\paragraph}{\@startsection{paragraph}{4}{0ex}%
   {-3.25ex plus -1ex minus -0.2ex}%
   {1.5ex plus 0.2ex}%
   {\normalfont\normalsize\bfseries}}
\makeatother

\makeatletter
\def\url@biburlstyle{%
\@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother

%\makeatletter
%\newcounter {subsubsubsection}[subsubsection]
%\renewcommand\thesubsubsubsection{\thesubsubsection .\@alph\c@subsubsubsection}
%\newcommand\subsubsubsection{\@startsection{subsubsubsection}{4}{\z@}%
%                                     {-3.25ex\@plus -1ex \@minus -.2ex}%
%                                     {1.5ex \@plus .2ex}%
%                                     {\normalfont\normalsize\bfseries}}
%\renewcommand\paragraph{\@startsection{paragraph}{5}{\z@}%
%                                    {3.25ex \@plus1ex \@minus.2ex}%
%                                    {-1em}%
%                                    {\normalfont\normalsize\bfseries}}
%\renewcommand\subparagraph{\@startsection{subparagraph}{6}{\parindent}%
%                          

%                                       {-1em}%
%                                      {\normalfont\normalsize\bfseries}}
%\newcommand*\l@subsubsubsection{\@dottedtocline{4}{10.0em}{4.1em}}
%\renewcommand*\l@paragraph{\@dottedtocline{5}{10em}{5em}}
%\renewcommand*\l@subparagraph{\@dottedtocline{6}{12em}{6em}}
%\newcommand*{\subsubsubsectionmark}[1]{}
%\makeatother

%%\usepackage{hyperref}

%%\makeatletter
%%\def\toclevel@subsubsubsection{4}
%%\def\toclevel@paragraph{5}
%%\def\toclevel@subparagraph{6}
%%\makeatother

\title{Rapport de Projet TEP\\Une applet d'évaluation des lambda-termes utilisant O'Browser}
\author{Thibault DUPERRON \and Nicolas RIGNAULT}



\begin{document}
\renewcommand{\bibname}{}
\renewcommand{\refname}{}
\maketitle
\tableofcontents

\newpage
\section{Introduction}

\subsection{Projet}

L'objectif est de réaliser un évaluateur de lambda-termes en utilisation OBrowser. Il s'agit donc d'implémenter les fonctions d'alpha-conversion et de béta-réduction en Ocaml et d'afficher le tout dans un navigateur Internet en utilisant OBrowser.

2 projets ont déjà été réalisés en PHP\footnote{http://stoufete.free.fr/TEP/page\_accueil.php} et en Java\footnote{http://www-apr.lip6.fr/~chaillou/Public/enseignement/2010-2011/tep/public/PROGS/AppletLG.html}.\\

Le but est donc d'implémenter le même comportement en utilisant OBrowser.


\subsection{OBrowser}

\subsubsection{Présentation}
OBrowser\footnote{http://www.pps.jussieu.fr/~canou/obrowser/tutorial/} est un interpreteur de bytecode Ocaml écrit en Javascript par Benjamin Canou. Le but est de pouvoir exécuter du code Ocaml dans un navigateur internet. Des fonctions permettant de manipuler des balises html ont donc été ajoutées afin d'être 
utilisées dans les programmes Ocaml.

\subsubsection{Tutoriel}
Voici un exemple d'utilisation de OBrowser:\\

On souhaite créer un champ de saisie de texte et un bouton. Un clique sur le bouton entrainerait l'affichage du contenu du champ de saisie de texte. On a donc besoin d'un bouton, d'un champ de saisie de texte et eventuellement d'un emplacement où ecrire le texte (par exemple une balise div).

\subsection{Lambda-calcul}

\newpage
\section{Travail effecué}

\subsection{Parsing de chaîne de caractères}

\subsubsection{Objectif}
Le but de cette fonction est d'obtenir un arbre correspondant à la chaîne donnée.\\

Un type ``Term'' a été défini pour représenter les arbres pour le Lambda-calcul.
\begin{figure}[H]
\begin{center}
\begin{tabular}{c}

 \begin{lstlisting}
type term =
| Var of string
| Lambda of string * term
| App of term * term
 \end{lstlisting}

\end{tabular}
\end{center}
\caption{Type Term pour représenter les arbres pour le Lambda-calcul}
 \label{tree1}
\end{figure}
Ainsi, d'après ce type ``Term'' on souhaite donc obtenir un arbre. Ce dernier pourrait ainsi être facilement analysé pour pour pouvoir appliquer les fonctions nécessaires.
\\
\\\underline{Exemple:} L'expression (lx.xx)(lxy.xy) doit renvoyer l'arbre suivant

\begin{figure}[H]
\centering
  \psset{levelsep=1cm,nodesep=1mm}
  {\pstree{\Tr{App}}
	 {{\pstree{\Tr{Lambda x}}
		 {\pstree {\Tr{App}}
			  {
			   {\Tr{x}}
			   {\Tr{x}}
			  }
		 }
	 }
	{\pstree{\Tr{App}}
		 {\pstree {\Tr{Lambda x}}
			  {\pstree{\Tr{Lambda y}}
			   {{\Tr{x}}
			   {\Tr{y}}}
			  }
		 }
	}}
  }
\caption{Arbre correspondant à l'expression (lx.xx)(lxy.xy)}
 \label{tree1}
\end{figure}

\subsubsection{Algorithme}
L'algorithme utilisé est le suivant: la chaîne est analysée, caractère par caractère. Lorsque l'on recontre une parenthèse ouvrante, on cherche la prochaine parenthèse fermante correspondante. Puis, on relance la fonction sur le contenu de cette sous chaîne ainsi que sur le reste de la chaîne de départ. On constitut ainsi un sous arbre pour chaque chaine entre parenthèses. Ces chaines sont ensuites fusionnées dans l'ordre pour pouvoir obtenir l'arbre final.
Les différentes variables sont stockées dans des environnements avec leur attribut (savoir s'il s'agit d'un lambda par exemple).
\\
\\Exemple de décomposition pour la chaîne (lx.x(yz))(ly.y):
\begin{figure}[H]
\centering
  \psset{levelsep=1cm,nodesep=1mm}
  {\pstree{\Tr{(lx.x(yz))(ly.y)}}
	 {{\pstree {\Tr{(lx.x(yz))}}
			  {
			   {\Tr{(yz)}}
			   {\Tr{lx.x}}
			  }
		 
	 }
	{\Tr{(ly.y)}}
	}
  }
\caption{Arbre de décomposition de l'expression (lx.x(yz))(ly.y)}
 \label{tree2}
\end{figure}

Ici on commence donc par analyser la première expression : (lx.x(yz))\\
On stocke ``lx'' et ``x'' dans l'environnement et on analyse ensuite l'expression suivante ``yz''. Enfin on les fusionne.\\

On analyse ensuite l'expression suivante, (ly.y), on effectue le même traitement et on la fusionne avec l'expression précédente pour obtenir l'arbre final.
\begin{figure}[H]
\centering
  \psset{levelsep=1cm,nodesep=1mm}
  {\pstree{\Tr{App}}
	 {{\pstree{\Tr{Lambda x}}
		 {\pstree {\Tr{App}}
			  {
			   {\Tr{x}}
			   {\pstree {\Tr{App}}
			      {{\Tr{y}}
			       {\Tr{z}}}
			   }
			  }
		 }
	 }
	{\pstree{\Tr{Lambda y}}
		{\Tr{y}}


	}}
  }
\caption{Arbre correspondant à l'expression (lx.x(yz))(ly.y)}
 \label{tree3}
\end{figure}

\subsection{Implémentation Lambda-calcul}

\subsubsection{Choix du lambda à evaluer}

Le premier lambda à evaluer est celui qui est le plus à gauche dans l'arbre et dont le père est une Application.

Pour trouver ce sous arbre et sa position dans l'arbre d'origine, la fonction `rechercheLambda` fait un parcours recursif de l'arbre.
Pour chaque application, la fonction va regarder si un tel lambda existe dans le sous arbre gauche, si c'est le cas il renvoie le chemin vers ce lambda,
 sinon il regardera dans le sous arbre droit. Si aucun lambda n'est trouvé alors le chemin renvoyé est une liste vide.

\subsubsection{Alpha Conversion}


Les fonctions pour l'alpha conversion vont permettrent de modifier le nom des variables liées. En effet, dans le sous arbre trouvé par 
l'etape du choix du lambda à evaluer, on souhaite pouvoir renommer les variables liées sans modifier le sens de l'expression.\\

L'alpha conversion est faite en 3 étapes:
\begin{itemize}
 \item La fonction \textbf{listLambda} permet de lister tout les lambdas communs entre le sous arbre gauche et le sous arbre droit
 \item La fonction \textbf{listeNouveauNoms} permet, pour chaque lambda, de créer des couples (nom, nouveauNom) tel que le nouveau
nom de variable ne soit pas lié.
 \item La fonction \textbf{recreeArbreAlphaConv} permet de recréer un arbre en appliquant les modifications de noms de variables
\end{itemize}


\subsubsection{Beta Réduction}

  La fonction \textbf{recreeArbreBetaRed} permet grace aux informations données par l'étape du choix du lambda à evaluer d'effectuer la
beta réduction sur l'arbre.

  Pour cela, la fonction va laisser en l'état toutes les parties de l'arbre non concernées par la beta réduction, et va modifier
le sous arbre identifié précédement en remplacant chaque occurrence de la variable du lambda à réduire par le sous arbre
droit.

\end{document}
